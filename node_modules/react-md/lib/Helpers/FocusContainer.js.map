{"version":3,"sources":["../../src/js/Helpers/FocusContainer.js"],"names":["hrefables","map","tag","join","disableables","FOCUSABLE_QUERY","FocusContainer","_enableFocusTrap","window","addEventListener","_handleKeyDown","_disableFocusTrap","removeEventListener","_attemptInitialFocus","_container","initialFocus","props","toFocus","document","getElementById","querySelector","_focusables","debugError","focus","_containFocus","containerRef","focusOnMount","containFocus","Array","prototype","slice","call","querySelectorAll","filter","el","tabIndex","e","_shifted","shiftKey","additionalFocusKeys","length","preventDefault","target","first","focusables","last","nextProps","Component","component","propTypes","oneOfType","string","func","isRequired","style","object","className","children","node","bool","arrayOf","number","defaultProps"],"mappings":"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","file":"FocusContainer.js","sourcesContent":["import React, { PureComponent } from 'react';\nimport PropTypes from 'prop-types';\nimport { findDOMNode } from 'react-dom';\nimport invariant from 'invariant';\n\nimport isValidFocusKeypress from '../utils/EventUtils/isValidFocusKeypress';\n\nconst hrefables = ['a', 'area'].map(tag => `${tag}[href],`).join('');\nconst disableables = ['button', 'input', 'textarea', 'select'].map(tag => `${tag}:not([disabled]),`).join('');\nconst FOCUSABLE_QUERY = `${hrefables}${disableables}*[tabIndex]`;\n\n/**\n * This component is used for keeping the focus within some container. When the container\n * is mounted and the `focusOnMount` prop is `true`, it will attempt to focus either:\n * - an element that matches `document.getElementById(this.props.initialFocus)`\n * - an element that matches `this._container.querySelector(this.props.initialFocus)`\n * - the first focusable element in it's children (if `this.props.initialFocus` is omitted)\n */\nexport default class FocusContainer extends PureComponent {\n  static propTypes = {\n    /**\n     * The component to render as. This can be a React DOM element or\n     * a react Component.\n     */\n    component: PropTypes.oneOfType([\n      PropTypes.string,\n      PropTypes.func,\n    ]).isRequired,\n\n    /**\n     * An optional style to apply.\n     */\n    style: PropTypes.object,\n\n    /**\n     * An optional className to apply.\n     */\n    className: PropTypes.string,\n\n    /**\n     * The children to display.\n     */\n    children: PropTypes.node,\n\n    /**\n     * An optional id string or a query selector string to use for the initial focus.\n     * This will only be triggered if the `focusOnMount` prop is `true`. If this is\n     * omitted and the `focusOnMount` prop is `true`, the first focusable element in the\n     * container will be focused.\n     *\n     * Examples:\n     *\n     * ```js\n     * initialFocus=\"#someAmazingId\"\n     * // or\n     * initialFocus=\".md-btn,.md-list-tile\"\n     * ```\n     */\n    initialFocus: PropTypes.string,\n\n    /**\n     * Boolean if an element in the container should be focused when mounted.\n     */\n    focusOnMount: PropTypes.bool,\n\n    /**\n     * An optional list of additional key codes to use for focus events.\n     */\n    additionalFocusKeys: PropTypes.arrayOf(PropTypes.number),\n\n    /**\n     * Boolean if the focus container should start or stop containing the focus within the container.\n     * This is useful for changing the focus requirements after mount.\n     */\n    containFocus: PropTypes.bool,\n  };\n\n  static defaultProps = {\n    component: 'div',\n    containFocus: true,\n  };\n\n  componentWillReceiveProps(nextProps) {\n    if (this.props.containFocus === nextProps.containFocus) {\n      return;\n    }\n\n    if (nextProps.containFocus) {\n      this._enableFocusTrap();\n      this._attemptInitialFocus();\n    } else {\n      this._disableFocusTrap();\n    }\n  }\n\n  componentDidUpdate() {\n    if (this.props.containFocus && this._container) {\n      this._focusables = Array.prototype.slice.call(this._container.querySelectorAll(FOCUSABLE_QUERY))\n        .filter(el => el.tabIndex !== -1);\n    }\n  }\n\n  componentWillUnmount() {\n    if (this.props.containFocus) {\n      this._disableFocusTrap();\n    }\n  }\n\n  _enableFocusTrap = () => {\n    window.addEventListener('keydown', this._handleKeyDown, true);\n  };\n\n  _disableFocusTrap = () => {\n    window.removeEventListener('keydown', this._handleKeyDown, true);\n  };\n\n  _attemptInitialFocus = () => {\n    if (!this._container) {\n      return;\n    }\n\n    const { initialFocus } = this.props;\n\n    const toFocus = initialFocus\n      ? document.getElementById(initialFocus) || this._container.querySelector(initialFocus)\n      : this._focusables[0];\n\n    let debugError;\n    if (!toFocus && initialFocus) {\n      debugError = ' The `initialFocus` did not match a document\\'s `id` or was an invalid ';\n      debugError += `\\`querySelector\\` for the container. \\`initialFocus\\`: \\`${initialFocus}\\`. `;\n      debugError += 'If this was supposed to be an `id`, make sure to prefix with the `#` symbol.';\n    }\n\n    invariant(\n      toFocus,\n      'You specified that the `FocusContainer` should focus an element on mount, ' +\n      'but a focusable element was not found in the children. This could be because ' +\n      'the `initialFocus` prop is an invalid id or query selector, or the children ' +\n      `do not contain a valid focusable element.${debugError}`\n    );\n\n    if (toFocus) {\n      toFocus.focus();\n    }\n  };\n\n  /**\n   * Manages the event listeners to contain the focus within some container.  When the container\n   * ref is not null, the container has mounted and then attempts to focus an element inside\n   * if the `focusOnMount` prop is `true`.\n   */\n  _containFocus = (containerRef) => {\n    if (containerRef === null) {\n      this._container = null;\n      this._disableFocusTrap();\n      return;\n    }\n\n    const { focusOnMount, containFocus } = this.props;\n    this._container = findDOMNode(containerRef);\n    this._focusables = Array.prototype.slice.call(this._container.querySelectorAll(FOCUSABLE_QUERY))\n      .filter(el => el.tabIndex !== -1);\n\n    if (focusOnMount) {\n      this._attemptInitialFocus();\n    }\n\n    if (containFocus) {\n      this._enableFocusTrap();\n    }\n  };\n\n  _handleKeyDown = (e) => {\n    this._shifted = e.shiftKey;\n    if (!isValidFocusKeypress(e, this.props.additionalFocusKeys)) {\n      return;\n    } else if (this._focusables.length === 1) {\n      e.preventDefault();\n      return;\n    }\n\n    const { target, shiftKey } = e;\n    const [first, ...focusables] = this._focusables;\n    const last = focusables[focusables.length - 1];\n\n    if (shiftKey && target === first) {\n      e.preventDefault();\n      last.focus();\n    } else if (!shiftKey && target === last) {\n      e.preventDefault();\n      first.focus();\n    }\n  };\n\n  render() {\n    const {\n      component: Component,\n      /* eslint-disable no-unused-vars */\n      initialFocus,\n      focusOnMount,\n      containFocus,\n      additionalFocusKeys,\n      /* eslint-enable no-unused-vars */\n      ...props\n    } = this.props;\n\n    return <Component {...props} ref={this._containFocus} />;\n  }\n}\n"]}