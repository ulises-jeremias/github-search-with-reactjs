{"version":3,"sources":["../../src/js/Helpers/Layover.js"],"names":["Layover","props","child","Children","only","children","state","below","right","styles","style","_lastXFix","_lastYFix","_initialX","_initialY","_initialTop","_initialLeft","_child","_toggle","process","env","NODE_ENV","window","addEventListener","_setContainer","_container","visible","fixedTo","sameWidth","centered","simplified","anchor","_getAnchor","_handleOutsideClick","rect","_contextRect","getBoundingClientRect","_dialog","_manageFixedToListener","_inFixed","_init","nextProps","_reset","visibileDiff","childStyle","setState","prevProps","closeOnOutsideClick","enabled","prevEnabled","_clickTimeout","clearTimeout","setTimeout","_manageWindowResizeListener","belowAnchor","animationPosition","Positions","BELOW","x","y","offsetWidth","offsetHeight","left","top","CENTER","width","INNER_RIGHT","LEFT","height","TOP","BOTTOM","bottom","className","block","toggle","fullWidth","fillViewportWidth","fillViewportHeight","onClose","repositionOnScroll","repositionOnResize","toggleQuery","yThreshold","xThreshold","onContextMenu","preventContextMenu","minLeft","minRight","minBottom","childId","id","cloneElement","ref","_fixateChild","observer","_handleResize","transitionEnterTimeout","transitionLeaveTimeout","_handleContextMenu","HorizontalAnchors","VerticalAnchors","propTypes","oneOfType","number","string","object","bool","isRequired","node","func","element","component","transitionName","defaultProps","INNER_LEFT","OVERLAP","add","listener","_handleScroll","_windowResizeTimeout","_handleWindowResize","removeEventListener","_mergeStyles","Math","max","maxHeight","centeredDialog","classList","contains","scroll","dialogRect","RIGHT","_initialWinX","_initialWinY","transformOrigin","undefined","container","querySelector","error","Error","fixed","getComputedStyle","position","match","offsetParent","_initialFix","clone","cloneNode","webkitTransform","transfrom","webkitTransition","transition","parentNode","appendChild","vp","childHeight","childWidth","removeChild","toggleHeight","toggleWidth","addToTop","addToLeft","multiplier","_childComponent","_positionChild","_height","_width","_createStyles","e","_ticking","requestAnimationFrame","_handleTick","_attemptFix","winX","winY","target","toggleTop","innerHeight","newTop","scrollEl","preventDefault"],"mappings":"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","file":"Layover.js","sourcesContent":["import React, { PureComponent } from 'react';\nimport { findDOMNode } from 'react-dom';\nimport PropTypes from 'prop-types';\nimport CSSTransitionGroup from 'react-transition-group/CSSTransitionGroup';\nimport cn from 'classnames';\n\nimport handleWindowClickListeners from '../utils/EventUtils/handleWindowClickListeners';\nimport getSelectedTextPosition from '../utils/Positioning/getSelectedTextPosition';\nimport getScroll from '../utils/Positioning/getScroll';\nimport viewport from '../utils/Positioning/viewport';\nimport isOutOfBounds from '../utils/Positioning/isOutOfBounds';\nimport anchorShape from './anchorShape';\nimport fixedToShape from './fixedToShape';\nimport positionShape from './positionShape';\nimport HorizontalAnchors from './HorizontalAnchors';\nimport VerticalAnchors from './VerticalAnchors';\nimport Positions from './Positions';\nimport ResizeObserver from './ResizeObserver';\n\n/**\n * The Layover component is used to keep a component fixed to another component\n * while the page is scrolling or a container is scrolling. When the fixed component\n * is considered out of view, it will be closed.\n *\n * > NOTE: Don't look at source code. Plz.\n */\nexport default class Layover extends PureComponent {\n  static HorizontalAnchors = HorizontalAnchors;\n  static VerticalAnchors = VerticalAnchors;\n  static Positions = Positions;\n\n  static propTypes = {\n    /**\n     * A id to give the layover itself. This is generally recommended for accessibility. If the\n     * child does not have an id, the child will automatically be updated to be `${id}-layover`.\n     */\n    id: PropTypes.oneOfType([\n      PropTypes.number,\n      PropTypes.string,\n    ]),\n\n    /**\n     * An optional style to apply to the layover.\n     */\n    style: PropTypes.object,\n\n    /**\n     * An optional className to apply to the layover.\n     */\n    className: PropTypes.string,\n\n    /**\n     * Boolean if the layover's child is currently visible.\n     */\n    visible: PropTypes.bool.isRequired,\n\n    /**\n     * This should either be a single element or two elements that the layover recalculates\n     * its fixed position when scrolling for horizontal and vertical.\n     *\n     * When it is a single element, it will recalculate for both horizontal and vertical\n     * scrolling. Otherwise, you can specify the element for horizontal scrolling and a\n     * separate element for vertical scrolling. If one is omitted, it will default to `window`.\n     *\n     * If the component is no longer considered to be in view after scrolling, the `onClose`\n     * prop will be called.\n     */\n    fixedTo: fixedToShape.isRequired,\n\n    /**\n     * The renderable item that causes the Layover to become visible. This _should_\n     * most likely be an `element` or `arrayOf(element)`, but anything is allowed.\n     */\n    toggle: PropTypes.node,\n\n    /**\n     * Since the `toggle` prop can be anything, I need a way to be able to find an\n     * element to base all the calculations on. This can either be a string that\n     * gets passed to `layover.querySelector`, a DOM Element, or a function that\n     * returns a DOM Element.\n     */\n    toggleQuery: PropTypes.oneOfType([\n      PropTypes.func,\n      PropTypes.object,\n      PropTypes.string,\n    ]).isRequired,\n\n    /**\n     * A single child that should be fixed to the toggle element.\n     */\n    children: PropTypes.element.isRequired,\n\n    /**\n     * Boolean if the Layover should be displayed as a block instead of as an inline block.\n     */\n    block: PropTypes.bool,\n\n    /**\n     * Boolean if the `children` should be centered horizontally and vertically while keeping\n     * its height in mind as well. This is *only* valid if both the x and y `anchor` targets\n     * are `CENTER`.\n     */\n    centered: PropTypes.bool,\n\n    /**\n     * Boolean if the layover should gain the `md-full-width` class name.\n     */\n    fullWidth: PropTypes.bool,\n\n    /**\n     * Boolean if the width of the children should be updated automatically to be the width\n     * of the toggle element.\n     */\n    sameWidth: PropTypes.bool,\n\n    /**\n     * The minimum value the `left` style can be for the child component. This is really just used\n     * to make sure it doesn't scroll off the left of the page. It can also be used to make\n     * full screen layovers on devices when when the `fillViewportWidth` prop is enabled.\n     *\n     * This can either be a number of pixels or a string for percentages. If this value is a string\n     * **it will always be used over the calculated values** so it is preferred to use a number.\n     *\n     * @see {@link #minRight}\n     * @see {@link #fillViewportWidth}\n     */\n    minLeft: PropTypes.oneOfType([\n      PropTypes.number,\n      PropTypes.string,\n    ]).isRequired,\n\n    /**\n     * The minimum value the `right` style can be for the child component. This is really just used\n     * to make sure it doesn't scroll off the right of the page when the `fillViewportWidth` prop is\n     * enabled.\n     *\n     * This can either be a number of pixels or a string for percentages. If this value is a string\n     * **it will always be used over the calculated values** so it is preferred to use a number.\n     *\n     * @see {@link #minLeft}\n     * @see {@link #fillViewportWidth}\n     */\n    minRight: PropTypes.oneOfType([\n      PropTypes.number,\n      PropTypes.string,\n    ]).isRequired,\n\n    /**\n     * The minimum value that can be used for the `bottom` prop when the `fillViewportHeight` prop is enabled.\n     * It is generally recommended to keep this value at `0` to keep it stretched to the bottom of the viewport\n     * or setting it to a small positive number to add some padding.\n     *\n     * This can either be a number of pixels or a string for percentages. If this value is a string\n     * **it will always be used over the calculated values** so it is preferred to use a number.\n     *\n     * @see {@link #fillViewportHeight}\n     */\n    minBottom: PropTypes.number.isRequired,\n\n    /**\n     * Boolean if the layover should make the child fill the entire viewport's width. This will just\n     * style the child element with:\n     *\n     * ```js\n     * childStyle = {\n     *   left: this.props.minLeft,\n     *   right: this.props.minRight,\n     * };\n     * ```\n     *\n     * If you add any additional constraints such as `width` or `max-width`, it will not span the entire viewport's\n     * width. This prop should generally really only be used on mobile devices. Using this prop along with\n     * `fillViewportHeight` for Autocompletes can create great Android mobile searches. See the `fillViewportHeight`\n     * for more information about why it is *only Android*.\n     *\n     * @see {@link #minLeft}\n     * @see {@link #minRight}\n     * @see {@link #fillViewportHeight}\n     */\n    fillViewportWidth: PropTypes.bool,\n\n    /**\n     * Boolean if the layover should fill the height of the viewport from the current calculated `top`. This will just\n     * style the child element with:\n     *\n     * ```js\n     * childStyle = {\n     *   top: currentCalculatedTop,\n     *   bottom: this.props.minBottom,\n     *   maxHeight: 'none',\n     * };\n     * ```\n     *\n     * This is *super* nice on Android devices since it will allow you to create nice toolbar search autocompletes\n     * in your app and the list of items will grow until it reaches the soft keyboard. It isn't as nice on iOS since\n     * iOS does not subtract the soft keyboard from the viewport's size so the list will still extend to the bottom\n     * of the page.\n     *\n     * @see {@link #minBottom}\n     * @see {@link #fillViewportWidth}\n     */\n    fillViewportHeight: PropTypes.bool,\n\n    /**\n     * A function used to hide the visibility of the children when the children are no longer\n     * visible or an element outside of the layover is clicked.\n     */\n    onClose: PropTypes.func.isRequired,\n\n    /**\n     * The component to render the Layover as.\n     */\n    component: PropTypes.oneOfType([\n      PropTypes.string,\n      PropTypes.func,\n    ]).isRequired,\n\n    /**\n     * The transition name to use for the children appearing/disappearing.\n     */\n    transitionName: PropTypes.string.isRequired,\n\n    /**\n     * The transition duration for the enter animation. The animation can be disabled by setting\n     * this value to 0.\n     */\n    transitionEnterTimeout: PropTypes.number.isRequired,\n\n    /**\n     * The transition duration for the leave animation. The animation can be disabled by setting\n     * this value to 0.\n     */\n    transitionLeaveTimeout: PropTypes.number.isRequired,\n\n    /**\n     * This is a threshold that is used to calculate if the `children` is still in\n     * view by applying this multiplier to the `children`'s width.\n     */\n    xThreshold: PropTypes.number.isRequired,\n\n    /**\n     * This is a threshold that is used to calculate if the `children` is still in\n     * view by applying this multiplier to the `toggle`'s height.\n     */\n    yThreshold: PropTypes.number.isRequired,\n\n    /**\n     * Boolean if the `children` should be hidden when an element outside\n     * of the `Layout` component has been clicked.\n     */\n    closeOnOutsideClick: PropTypes.bool.isRequired,\n\n    /**\n     * This is how the children get \"anchored\" to the `toggle` element and how the\n     * auto-fix attempts will be made. Right now, the auto fixes will only be handled\n     * on viewport boundaries instead of `fixedTo` boundaries. It was too hard for\n     * first attempt.\n     *\n     * The general behavior will be that an equal-opposite of an anchor will be chosen\n     * when that direction is out of viewport. So for example, the children are out\n     * of viewport for the right of the screen, and the `anchor.x` value is\n     * `Layover.HorizontalPositions.RIGHT`, the children will be swapped to be the `LEFT`\n     * of the `toggle` component now.\n     *\n     * So a full list:\n     * - `LEFT` / `RIGHT`\n     * - `INNER_LEFT` / `INNER_RIGHT`\n     * - `TOP` / `BOTTOM`\n     *\n     * The `CENTER` and `OVERLAP` positions can not be automatically adjusted.\n     *\n     * > To be safe, you should use the enum values for the `x` and `y` values.\n     * @see {@link #VerticalAnchors}\n     * @see {@link #HorizontalAnchors}\n     */\n    anchor: anchorShape.isRequired,\n\n    /**\n     * This is how the children get \"anchored\" when the `animationPositions` is set to `Layover.Positions.BELOW`.\n     * Set this to `null` to continue using the base `anchor` prop instead of switching to this anchor.\n     *\n     * @see {@link #anchor}\n     */\n    belowAnchor: anchorShape,\n\n    /**\n     * This is the position that the children should animate from. It directly ties into\n     * the `$md-layover-child-positions` Sass variable.\n     */\n    animationPosition: positionShape.isRequired,\n\n    /**\n     * If you would like the layover to interact as a context menu, provide this prop. It will\n     * make the children appear relative to the context menu origin automatically.\n     *\n     * @see {@link #preventContextMenu}\n     */\n    onContextMenu: PropTypes.func,\n\n    /**\n     * Boolean if the default behavior of the context menu should be prevented when using the\n     * `onContextMenu` prop.\n     *\n     * @see {@link #onContextMenu}\n     */\n    preventContextMenu: PropTypes.bool,\n\n    /**\n     * Boolean if the layover should attempt to automatically adjust the position of the element to\n     * keep it within the viewport. If this value is set to `false`, the `onClose` prop will be called\n     * instead.\n     */\n    repositionOnScroll: PropTypes.bool,\n\n    /**\n     * Boolean if the layover should attempt to automatically adjust the position of the element to\n     * keep it within the viewport. If this value is set to `false`, the `onClose` prop will be called\n     * instead.\n     */\n    repositionOnResize: PropTypes.bool,\n\n    /**\n     * Boolean if the layover should become \"simplified\". This basically disables all the logic for\n     * keeping the child within the viewport and allows you to manage all the positioning via CSS.\n     *\n     * When this is enabled, it updates the `Layover` to have `position: relative` while the child will\n     * have `position: absolute` which will allow for simple `top`, `right`, `bottom`, and/or `left` CSS\n     * to position as wanted.\n     *\n     * This is really only helpful in cases where the layover can't calculate things correctly due to\n     * being in fixed containers somewhere in the page or some other weird stuff. Hopefully this won't\n     * really need to be used much.\n     */\n    simplified: PropTypes.bool,\n  };\n\n  static defaultProps = {\n    anchor: {\n      x: Layover.HorizontalAnchors.INNER_LEFT,\n      y: Layover.VerticalAnchors.OVERLAP,\n    },\n    belowAnchor: {\n      x: Layover.HorizontalAnchors.CENTER,\n      y: Layover.VerticalAnchors.BOTTOM,\n    },\n    animationPosition: Layover.Positions.BELOW,\n    repositionOnScroll: true,\n    repositionOnResize: false,\n    component: 'div',\n    fixedTo: typeof window !== 'undefined' ? window : {},\n    toggleQuery: '.md-text-field-container,button,*[role=\"button\"],*[role=\"listbox\"]',\n    transitionName: 'md-layover',\n    transitionEnterTimeout: 200,\n    transitionLeaveTimeout: 200,\n    yThreshold: 0.38,\n    xThreshold: 0.38,\n    closeOnOutsideClick: true,\n    preventContextMenu: true,\n    simplified: false,\n    minLeft: 0,\n    minRight: 0,\n    minBottom: 0,\n    fillViewportWidth: false,\n    fillViewportHeight: false,\n  };\n\n  constructor(props) {\n    super();\n\n    const child = React.Children.only(props.children);\n    this.state = {\n      below: false,\n      right: false,\n      styles: child.props.style,\n    };\n\n    this._lastXFix = null;\n    this._lastYFix = null;\n    this._initialX = null;\n    this._initialY = null;\n    this._initialTop = null;\n    this._initialLeft = null;\n    this._child = null;\n    this._toggle = null;\n  }\n\n  componentDidMount() {\n    if (process.env.NODE_ENV === 'development') {\n      window.addEventListener('load', () => {\n        this._setContainer(this._container);\n      });\n    }\n\n    const { visible, fixedTo, sameWidth, centered, simplified } = this.props;\n    const anchor = this._getAnchor(this.props);\n    if (visible) {\n      handleWindowClickListeners(this._handleOutsideClick, true);\n\n      // Don't worry about any of the other logic for a \"simple\" layover\n      if (simplified) {\n        return;\n      }\n\n      const rect = this._contextRect || this._toggle.getBoundingClientRect();\n      if (this._dialog) {\n        this._manageFixedToListener(this._dialog, true);\n      } else if (!this._inFixed) {\n        this._manageFixedToListener(fixedTo, true);\n      }\n\n      this._init(fixedTo, anchor, sameWidth, centered, rect);\n    }\n  }\n\n  componentWillReceiveProps(nextProps) {\n    const { fixedTo, visible, children, sameWidth, centered, simplified } = nextProps;\n    if (simplified) {\n      if (this.props.simplified !== simplified) {\n        this._reset();\n      }\n      return;\n    }\n\n    const anchor = this._getAnchor(nextProps);\n    const visibileDiff = visible !== this.props.visible;\n    const childStyle = React.Children.only(children).props.style;\n\n    if (visibileDiff) {\n      if (!visible) {\n        this._reset();\n      } else {\n        // Initialize the layover logic\n        const rect = this._contextRect || this._toggle.getBoundingClientRect();\n        if (this._dialog) {\n          this._manageFixedToListener(this._dialog, true);\n        } else if (!this._inFixed) {\n          this._manageFixedToListener(fixedTo, true);\n        }\n\n        this._init(fixedTo, anchor, sameWidth, centered, rect);\n      }\n    } else if (fixedTo !== this.props.fixedTo && visible) {\n      // swap the fixedTo listeners\n      this._manageFixedToListener(this.props.fixedTo, false);\n      this._manageFixedToListener(fixedTo, true);\n    } else if (childStyle !== React.Children.only(this.props.children).props.style) {\n      // Re-merge styles... This is only required if all the others fail since all the other\n      // logic always merges styles with the children styles\n      this.setState({ styles: { ...this.state.styles, ...childStyle } });\n    }\n  }\n\n  componentDidUpdate(prevProps) {\n    const { visible, closeOnOutsideClick } = this.props;\n    const enabled = visible && closeOnOutsideClick;\n    const prevEnabled = prevProps.visible && prevProps.closeOnOutsideClick;\n    if (enabled !== prevEnabled) {\n      if (this._clickTimeout) {\n        clearTimeout(this._clickTimeout);\n        this._clickTimeout = null;\n      }\n\n      // This is really an arbitrary timeout time, but firefox needs to have a timeout\n      // so the context menu doesn't close automatically due to an \"outside click\" being\n      // triggered\n      this._clickTimeout = setTimeout(() => {\n        this._clickTimeout = null;\n        handleWindowClickListeners(this._handleOutsideClick, enabled);\n      }, enabled ? 300 : 0);\n    }\n  }\n\n  componentWillUnmount() {\n    if (this._clickTimeout) {\n      clearTimeout(this._clickTimeout);\n      this._clickTimeout = null;\n    }\n    handleWindowClickListeners(this._handleOutsideClick, false);\n\n    if (!this.props.simplified) {\n      this._manageFixedToListener(this.props.fixedTo, false);\n      this._manageWindowResizeListener(false);\n    }\n  }\n\n  _getAnchor({ anchor, belowAnchor, animationPosition }) {\n    return animationPosition === Layover.Positions.BELOW && belowAnchor || anchor;\n  }\n\n  _createStyles(anchor, centered, child, rect) {\n    const { x, y } = anchor;\n    const { offsetWidth, offsetHeight } = child;\n\n    let left;\n    let top;\n    if (x === HorizontalAnchors.CENTER) {\n      left = rect.left + (rect.width / 2) - (offsetWidth / 2);\n    } else if (x === HorizontalAnchors.INNER_RIGHT) {\n      left = rect.right - offsetWidth;\n    } else if (x === HorizontalAnchors.LEFT) {\n      left = rect.left - offsetWidth;\n    }\n\n    if (centered && x === HorizontalAnchors.CENTER && y === VerticalAnchors.CENTER) {\n      top = rect.top - (offsetHeight / 2) + (rect.height / 2);\n    } else if (y === VerticalAnchors.TOP) {\n      top = rect.top - offsetHeight;\n    } else if (y === VerticalAnchors.CENTER) {\n      top = rect.top + rect.height / 2;\n    } else if (y === VerticalAnchors.BOTTOM) {\n      top = rect.bottom;\n    }\n\n    const style = {};\n    if (top) {\n      style.top = top;\n    }\n\n    if (left) {\n      style.left = left;\n    }\n\n    return style;\n  }\n\n  /**\n   * Whew. Ok. So since the fixedTo prop can either be two elements or a single item,\n   * this utility function is used to add/remove the scrolling event listeners for\n   * this prop.\n   *\n   * When the fixedTo prop has a horizontal and/or vertical attribute, the `window`\n   * will be the fallback option. If both the horizontal and vertical attributes are\n   * defined, the `window` still needs to have a scroll listener to make sure it\n   * doesn't go off screen.\n   */\n  _manageFixedToListener = (fixedTo, add) => {\n    const listener = `${add ? 'add' : 'remove'}EventListener`;\n    if (fixedTo !== window && (fixedTo.x || fixedTo.y)) {\n      const { x, y } = fixedTo;\n      if (x) {\n        x[listener]('scroll', this._handleScroll);\n      } else {\n        window[listener]('scroll', this._handleScroll);\n      }\n\n      if (y) {\n        y[listener]('scroll', this._handleScroll);\n      } else if (!x) {\n        // Only add the window event listener once\n        window[listener]('scroll', this._handleScroll);\n      }\n\n      if (y && y !== window && x && x !== window) {\n        window[listener]('scroll', this._handleScroll);\n      }\n    } else {\n      fixedTo[listener]('scroll', this._handleScroll);\n\n      if (fixedTo !== window) {\n        window[listener]('scroll', this._handleScroll);\n      }\n    }\n  };\n\n  _manageWindowResizeListener = (enabled) => {\n    if (this._windowResizeTimeout) {\n      clearTimeout(this._windowResizeTimeout);\n      this._windowResizeTimeout = null;\n    }\n\n    if (enabled) {\n      // add a 2 second delay before watching resize events since Android soft keyboards trigger a resize event.\n      this._windowResizeTimeout = setTimeout(() => {\n        this._windowResizeTimeout = null;\n        window.addEventListener('resize', this._handleWindowResize);\n      }, 2000);\n    } else {\n      window.removeEventListener('resize', this._handleWindowResize);\n    }\n  };\n\n  /**\n   * This is just a simple utility function to merge the existing state styles,\n   * any new styles, and the children's styles (with most precedence).\n   */\n  _mergeStyles = (style) => {\n    const {\n      minLeft,\n      minRight,\n      minBottom,\n      fillViewportWidth,\n      fillViewportHeight,\n    } = this.props;\n    if (fillViewportWidth) {\n      style.left = minLeft;\n      style.right = minRight;\n    } else {\n      if (style.left) {\n        style.left = Math.max(minLeft, style.left);\n      }\n\n      if (style.right) {\n        style.right = Math.max(minRight, style.right);\n      }\n    }\n\n    if (fillViewportHeight) {\n      style.bottom = minBottom;\n      style.maxHeight = 'none';\n    } else {\n      // These styles are only created when filling the viewport height, so clear\n      // them out again\n      style.bottom = null;\n      style.maxHeight = null;\n    }\n\n    return {\n      ...this.state.styles,\n      ...style,\n      ...React.Children.only(this.props.children).props.style,\n    };\n  };\n\n  /**\n   * This initializes the popover with the default styles, and the initial bookkeeping\n   * variables to update while it is open.\n   */\n  _init = (fixedTo, anchor, sameWidth, centered, rect) => {\n    if (this._child) {\n      // The init function can be called again if the user quickly toggles the layover. If that\n      // is the case, we want the styles that were set after the _positionChild _attemptFix.\n      return;\n    }\n\n    const centeredDialog = this._dialog && this._dialog.classList.contains('md-dialog--centered');\n    const { height, width } = rect;\n    let { top, left, right } = rect;\n    let x;\n    let y;\n    if (this._dialog) {\n      const scroll = getScroll(this._dialog);\n      x = scroll.x;\n      y = scroll.y;\n\n      if (centeredDialog) {\n        const dialogRect = this._dialog.getBoundingClientRect();\n        left -= dialogRect.left;\n        top -= dialogRect.top;\n        right -= dialogRect.right;\n      }\n    } else if (fixedTo !== window && (fixedTo.y || fixedTo.x)) {\n      x = getScroll(fixedTo.x || window).x;\n      y = getScroll(fixedTo.y || window).y;\n    } else {\n      const scroll = getScroll(fixedTo);\n      x = scroll.x;\n      y = scroll.y;\n    }\n\n    this._initialX = x;\n    this._initialY = y;\n    this._initialLeft = left;\n    this._initialTop = top;\n\n    if (anchor.x === HorizontalAnchors.INNER_RIGHT) {\n      this._initialLeft = left + width;\n    } else if (anchor.x === HorizontalAnchors.RIGHT) {\n      this._initialLeft = right;\n    }\n\n    if (!centered) {\n      this._lastYFix = anchor.y === VerticalAnchors.TOP ? 'bottom' : 'top';\n    } else {\n      // Centered is not fixable\n      this._lastYFix = null;\n    }\n    if (anchor.x === HorizontalAnchors.LEFT || anchor.x === HorizontalAnchors.INNER_LEFT) {\n      this._lastXFix = 'right';\n    } else if (anchor.x === HorizontalAnchors.RIGHT || anchor.x === HorizontalAnchors.INNER_RIGHT) {\n      this._lastXFix = 'left';\n    } else {\n      // Can't fix others\n      this._lastXFix = null;\n    }\n\n    if (anchor.y === VerticalAnchors.BOTTOM) {\n      this._initialTop = top + height;\n    }\n\n    if (fixedTo !== window && !fixedTo.y && !fixedTo.x) {\n      const scroll = getScroll(window);\n      this._initialWinX = scroll.x;\n      this._initialWinY = scroll.y;\n    }\n\n    const styles = this._mergeStyles({\n      left: this._initialLeft,\n      top: this._initialTop,\n      transformOrigin: undefined,\n      width: sameWidth ? width : undefined,\n    });\n\n    this.setState({ styles });\n  };\n\n  _reset = ({ fixedTo } = this.props) => {\n    // Reset all the bookkeeping variables for a fresh start on re-visible\n    this._lastXFix = null;\n    this._lastYFix = null;\n    this._initialX = null;\n    this._initialY = null;\n    this._initialTop = null;\n    this._initialLeft = null;\n\n    if (!this._inFixed) {\n      if (this._dialog) {\n        this._manageFixedToListener(this._dialog, false);\n      }\n\n      this._manageFixedToListener(fixedTo, false);\n    }\n  };\n\n  _setContainer = (container) => {\n    this._container = findDOMNode(container);\n    this._toggle = null;\n    if (!this._container) {\n      return;\n    }\n\n    const { toggleQuery, onContextMenu } = this.props;\n    if (typeof toggleQuery === 'function') {\n      this._toggle = toggleQuery();\n    } else if (typeof toggleQuery === 'string') {\n      this._toggle = this._container.querySelector(toggleQuery);\n    } else {\n      this._toggle = toggleQuery;\n    }\n\n    if (!this._toggle && !onContextMenu && process.env.NODE_ENV !== 'production') {\n      const error = new Error(\n        'Unable to find a toggle component with the provided `toggleQuery` and `toggle` element. \\n' +\n        `\\`toggleQuery\\`: \\`${toggleQuery}\\``\n      );\n      error.toggleQuery = toggleQuery;\n      error.toggle = this.props.toggle;\n\n      throw error;\n    }\n\n    let node = this._container;\n    while (node) {\n      const fixed = window.getComputedStyle(node).position === 'fixed';\n      if (fixed && node.className.match(/md-dialog--(full-page|centered)/)) {\n        this._dialog = node;\n        return;\n      } else if (fixed && !node.classList.contains('md-layover-child')) {\n        this._inFixed = true;\n        return;\n      }\n\n      node = node.offsetParent;\n    }\n  };\n\n  /**\n   * Attempts to fix the child by setting it's location ONLY for the entire\n   * page viewport. I didn't bother attempting to fix it for additional fixedTo\n   * stuff.\n   */\n  _initialFix = () => {\n    // Need to make a clone that disables any transitions to calculate positioning stuff\n    const clone = this._child.cloneNode(true);\n    clone.style.webkitTransform = 'none';\n    clone.style.transfrom = 'none';\n    clone.style.webkitTransition = 'none';\n    clone.style.transition = 'none';\n\n    this._child.parentNode.appendChild(clone);\n    const vp = viewport(clone);\n    const { offsetHeight: childHeight, offsetWidth: childWidth } = clone;\n    this._child.parentNode.removeChild(clone);\n\n    if (vp === true || !this._toggle || !this._child) {\n      return;\n    }\n\n    const { x, y } = this._getAnchor(this.props);\n    let toggleHeight;\n    let toggleWidth;\n    if (this._contextRect) {\n      toggleHeight = this._contextRect.height;\n      toggleWidth = this._contextRect.width;\n    } else {\n      toggleHeight = this._toggle.offsetHeight;\n      toggleWidth = this._toggle.offsetWidth;\n    }\n\n    let addToTop = 0;\n    let addToLeft = 0;\n\n    // Android devices will never get this far because they consider the keyboard as part\n    // of the viewport, iOS will and cause it to be a giant negative number. *sigh*\n    // Prevent any additional vertical positioning for iOS\n    if (!this.props.fillViewportHeight && (!vp.top || !vp.bottom)) {\n      const multiplier = vp.top ? -1 : 1;\n      if (!vp.bottom && y === VerticalAnchors.OVERLAP) {\n        addToTop += toggleHeight;\n      } else if (y === VerticalAnchors.TOP || y === VerticalAnchors.BOTTOM) {\n        addToTop += (multiplier * toggleHeight);\n      }\n\n      addToTop += (multiplier * childHeight);\n\n      this._lastYFix = vp.top ? 'bottom' : 'top';\n    }\n\n    if (!this.props.fillViewportWidth && x !== HorizontalAnchors.CENTER && (!vp.left || !vp.right)) {\n      if (!vp.left && x === HorizontalAnchors.LEFT) {\n        addToLeft += toggleWidth + childWidth;\n        this._lastXFix = 'left';\n      } else if (!vp.left && x === HorizontalAnchors.INNER_LEFT) {\n        addToLeft += toggleWidth;\n        this._lastXFix = 'left';\n      } else if (!vp.right && x === HorizontalAnchors.RIGHT) {\n        addToLeft -= (toggleWidth + childWidth);\n        this._lastXFix = 'right';\n      } else if (!vp.right && x === HorizontalAnchors.INNER_RIGHT) {\n        addToLeft -= toggleWidth;\n        this._lastXFix = 'right';\n      }\n    }\n\n    if (addToTop !== 0 || addToLeft !== 0) {\n      this._initialTop += addToTop;\n      this._initialLeft += addToLeft;\n\n      this.setState({ styles: this._mergeStyles({ top: this._initialTop, left: this._initialLeft }) });\n    }\n  };\n\n  /**\n   * When the child is initially mounted, it will update the styles for centering\n   * the element (if enabled) and then attempt to fix any viewport issues.\n   */\n  _fixateChild = (child) => {\n    this._child = findDOMNode(child);\n\n    if (this._child !== null) {\n      this._childComponent = React.Children.only(this.props.children);\n\n      // If child also has a ref callback, simulate the same thing\n      if (typeof this._childComponent.ref === 'function') {\n        this._childComponent.ref(child);\n      }\n\n      if (this.props.simplified || !this._child || (!this._toggle && !this._contextRect)) {\n        return;\n      }\n\n      if (this._dialog && this._dialog.classList.contains('md-dialog--centered')) {\n        return;\n      }\n\n      this._manageWindowResizeListener(true);\n      this._positionChild();\n    } else if (this._childComponent && typeof this._childComponent.ref === 'function') {\n      this._childComponent.ref(child);\n    }\n  };\n\n  _positionChild = () => {\n    const { centered } = this.props;\n    const anchor = this._getAnchor(this.props);\n    const rect = this._contextRect || this._toggle.getBoundingClientRect();\n    this._height = rect.height;\n    this._width = rect.width;\n    const styles = this._createStyles(anchor, centered, this._child, rect);\n    if (styles.top || styles.left) {\n      this._initialLeft = styles.left || this._initialLeft;\n      this._initialTop = styles.top || this._initialTop;\n      this.setState({ styles: this._mergeStyles(styles) }, this._initialFix);\n    } else {\n      this._initialFix();\n    }\n  };\n\n  _handleResize = () => {\n    if (this.props.visible) {\n      this._positionChild();\n    }\n  };\n\n  _handleScroll = (e) => {\n    if (!this.props.repositionOnScroll) {\n      this._manageFixedToListener(this.props.fixedTo, false);\n      this.props.onClose(e);\n    }\n\n    if (!this._ticking) {\n      requestAnimationFrame(() => this._handleTick(e));\n    }\n\n    this._ticking = true;\n  };\n\n  /**\n   * This is the meat of the stuff. Do lots of viewport / container checks to make sure\n   * the element should still be visible. If it is still visible, it will update its\n   * x and y position for the new scroll position.\n   */\n  _handleTick = (e) => {\n    const { fixedTo, xThreshold, yThreshold } = this.props;\n    const vp = viewport(this._child);\n    if (vp !== true && vp.left && vp.right) {\n      const fixed = !this._contextRect && this._attemptFix(vp);\n      if (!fixed) {\n        this.props.onClose(e);\n        this._ticking = false;\n      }\n\n      return;\n    } else if (\n      isOutOfBounds(fixedTo, this._child, this._toggle, yThreshold, xThreshold)\n    ) {\n      this.props.onClose(e);\n      this._ticking = false;\n      return;\n    }\n\n    let x;\n    let y;\n    if (this._dialog) {\n      const scroll = getScroll(this._dialog);\n      x = scroll.x;\n      y = scroll.y;\n    } else if (fixedTo !== window && (fixedTo.x || fixedTo.y)) {\n      x = getScroll(fixedTo.x || window).x;\n      y = getScroll(fixedTo.y || window).y;\n    } else {\n      const scroll = getScroll(fixedTo);\n      x = scroll.x;\n      y = scroll.y;\n    }\n\n    let winX;\n    let winY;\n    // When using the additional fixedTo stuff, need to also keep track of the entire\n    // window's scrolling..\n    if (fixedTo !== window && !fixedTo.x && !fixedTo.y) {\n      const scroll = getScroll(window);\n      winX = scroll.x;\n      winY = scroll.y;\n    }\n\n    const { styles } = this.state;\n    let { left, top } = styles;\n    if (this._initialX !== x) {\n      left = (this._initialX - x) + this._initialLeft;\n    }\n\n    if (winX && this._initialWinX !== winX) {\n      left = (this._initialWinX - winX) + this._initialX;\n    }\n\n    if (this._initialY !== y) {\n      top = (this._initialY - y) + this._initialTop;\n    }\n\n    if (winY && this._initialWinY !== winY) {\n      top = (this._initialWinY - winY) + this._initialTop + (this._initialY - y);\n    }\n\n    if (styles.top !== top || styles.left !== left) {\n      this.setState({ styles: this._mergeStyles({ left, top }) }, () => {\n        this._ticking = false;\n      });\n    } else {\n      this._ticking = false;\n    }\n  };\n\n  _handleOutsideClick = (e) => {\n    if (\n      (this._contextRect && this._child && !this._child.contains(e.target)) ||\n      (this._container && !this._container.contains(e.target))\n    ) {\n      this.props.onClose(e);\n    }\n  };\n\n  _handleWindowResize = (e) => {\n    const { onClose, repositionOnResize } = this.props;\n    if (repositionOnResize) {\n      this._handleResize();\n    } else {\n      onClose(e);\n      this._manageWindowResizeListener(false);\n    }\n  };\n\n  /**\n   * Attempts to fix a viewport problem by swapping the positioning. This only does\n   * vertical switching right now.\n   *\n   * @param {Object} vp - The result of the viewport function\n   * @return {boolean} true if the fix was able to be done and successful.\n   */\n  _attemptFix = (vp) => {\n    const { x, y } = this._getAnchor(this.props);\n    const centered = x === HorizontalAnchors.CENTER && y === VerticalAnchors.CENTER && this.props.centered;\n    if (centered || (this._lastYFix === 'top' && !vp.top) || (this._lastYFix === 'bottom' && !vp.bottom)) {\n      return false;\n    }\n\n    const toggleTop = this._toggle.getBoundingClientRect().top;\n    const { offsetHeight: toggleHeight } = this._toggle;\n    const { offsetHeight: childHeight } = this._child;\n\n    // Can;t fix if the child can't fit on the page based on the toggle's position\n    if (toggleTop + toggleHeight + childHeight > window.innerHeight) {\n      return false;\n    }\n\n    const { top } = this._child.getBoundingClientRect();\n    let newTop = this._initialTop;\n    let addToTop = childHeight * (vp.top ? -1 : 1);\n    if (y === VerticalAnchors.OVERLAP) {\n      addToTop += ((vp.top ? 1 : -1) * toggleHeight);\n    } else if (y === VerticalAnchors.TOP || y === VerticalAnchors.BOTTOM) {\n      addToTop += ((this._lastYFix === 'top' ? -1 : 1) * toggleHeight);\n    }\n\n    if (addToTop !== 0) {\n      newTop = top + addToTop;\n      this._lastYFix = vp.top ? 'bottom' : 'top';\n    }\n\n    if (newTop !== this._initialTop) {\n      this._initialTop = newTop;\n      const { fixedTo } = this.props;\n      let scrollEl = fixedTo;\n      if (fixedTo !== window && (fixedTo.y || fixedTo.x)) {\n        scrollEl = fixedTo.y || window;\n      }\n\n      this._initialY = getScroll(scrollEl).y;\n\n      this.setState({ styles: this._mergeStyles({ top: this._initialTop }) }, () => {\n        this._ticking = false;\n      });\n      return true;\n    }\n\n    return false;\n  };\n\n  _handleContextMenu = (e) => {\n    const anchor = this._getAnchor(this.props);\n    const { onContextMenu, preventContextMenu, fixedTo, sameWidth, centered, visible } = this.props;\n    if (!onContextMenu) {\n      return;\n    }\n\n    this._contextRect = getSelectedTextPosition(e);\n    if (preventContextMenu && (!this._child || !this._child.contains(e.target))) {\n      e.preventDefault();\n    }\n\n    onContextMenu(e);\n    if (visible) {\n      this._init(fixedTo, anchor, sameWidth, centered, this._contextRect);\n    }\n  };\n\n  render() {\n    const {\n      className,\n      block,\n      toggle,\n      visible,\n      children,\n      fullWidth,\n      animationPosition,\n      simplified,\n      fillViewportWidth,\n      fillViewportHeight,\n      /* eslint-disable no-unused-vars */\n      anchor,\n      belowAnchor,\n      onClose,\n      repositionOnScroll,\n      repositionOnResize,\n      sameWidth,\n      centered,\n      fixedTo,\n      toggleQuery,\n      yThreshold,\n      xThreshold,\n      onContextMenu,\n      preventContextMenu,\n      closeOnOutsideClick,\n      minLeft,\n      minRight,\n      minBottom,\n      /* eslint-enable no-unused-vars */\n      ...props\n    } = this.props;\n\n    let child;\n    let childId;\n    if (visible) {\n      child = React.Children.only(children);\n      if (child.props.id) {\n        childId = child.props.id;\n      } else if (props.id) {\n        childId = `${props.id}-layover`;\n      }\n\n      child = React.cloneElement(children, {\n        ref: this._fixateChild,\n        id: childId,\n        style: simplified ? child.props.style : this.state.styles,\n        className: cn(`md-layover-child md-layover-child--${animationPosition}`, {\n          'md-layover-child--simplified': simplified,\n        }, child.props.className),\n      });\n    }\n\n    let observer = null;\n    if (!simplified && (!fillViewportWidth && !fillViewportHeight)) {\n      observer = (\n        <ResizeObserver\n          watchWidth={!fillViewportWidth}\n          watchHeight={!fillViewportHeight}\n          target={this._child}\n          onResize={this._handleResize}\n        />\n      );\n    }\n\n    return (\n      <CSSTransitionGroup\n        {...props}\n        className={cn('md-layover', {\n          'md-layover--simplified': simplified,\n          'md-inline-block': !block && !fullWidth,\n          'md-full-width': fullWidth,\n        }, className)}\n        ref={this._setContainer}\n        aria-haspopup\n        aria-owns={childId}\n        aria-expanded={visible}\n        transitionEnter={props.transitionEnterTimeout !== 0}\n        transitionLeave={props.transitionLeaveTimeout !== 0}\n        onContextMenu={this._handleContextMenu}\n      >\n        {observer}\n        {toggle}\n        {child}\n      </CSSTransitionGroup>\n    );\n  }\n}\n"]}